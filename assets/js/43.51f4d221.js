(window.webpackJsonp=window.webpackJsonp||[]).push([[43],{309:function(t,v,_){"use strict";_.r(v);var s=_(13),a=Object(s.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"그래프-graph"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#그래프-graph"}},[t._v("#")]),t._v(" 그래프(Graph)")]),t._v(" "),v("h2",{attrs:{id:"그래프란-무엇인가요"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#그래프란-무엇인가요"}},[t._v("#")]),t._v(" 그래프란 무엇인가요?")]),t._v(" "),v("ul",[v("li",[t._v("정점(vertex)과 간선(edge)으로 이루어진 자료구조입니다.")]),t._v(" "),v("li",[t._v("연결되어 있는 객체 간의 관계를 표현할 수 있는 자료구조입니다.")]),t._v(" "),v("li",[t._v("부모-자식, 루트노드의 개념이 존재하지 않습니다.")]),t._v(" "),v("li",[t._v("지도, 지하철 노선도의 최단경로, 도로 등과 같은 문제에 사용합니다.")]),t._v(" "),v("li",[t._v("DFS, BFS를 통해 순회합니다.")])]),t._v(" "),v("h2",{attrs:{id:"그래프와-관련된-용어"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#그래프와-관련된-용어"}},[t._v("#")]),t._v(" 그래프와 관련된 용어")]),t._v(" "),v("ul",[v("li",[t._v("정점(vertex): 위치라는 개념. (node 라고도 부름)")]),t._v(" "),v("li",[t._v("간선(edge): 위치 간의 관계. 즉, 노드를 연결하는 선 (link, branch 라고도 부름)")]),t._v(" "),v("li",[t._v("인접 정점(adjacent vertex): 간선에 의해 직접 연결된 정점")]),t._v(" "),v("li",[t._v("차수(degree): 무방향 그래프에서 하나의 정점에 인접한 정점의 수")]),t._v(" "),v("li",[t._v("진입 차수(in-degree): 방향 그래프에서 외부에서 오는 간선의 수 (내차수 라고도 부름)")]),t._v(" "),v("li",[t._v("진출 차수(out-degree): 방향 그래픙에서 외부로 향하는 간선의 수 (외차수 라고도 부름)")]),t._v(" "),v("li",[t._v("경로 길이(path length): 경로를 구성하는 데 사용된 간선의 수")]),t._v(" "),v("li",[t._v("단순 경로(simple path): 경로 중에서 반복되는 정점이 없는 경우")]),t._v(" "),v("li",[t._v("사이클(cycle): 단순 경로의 시작 정점과 종료 정점이 동일한 경우")])]),t._v(" "),v("h2",{attrs:{id:"그래프의-종류"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#그래프의-종류"}},[t._v("#")]),t._v(" 그래프의 종류")]),t._v(" "),v("ul",[v("li",[t._v("가중치 그래프 : 간선에 비용(가중치)가 할당된 그래프로, 두 정점을 이동할 때 비용이 듭니다."),v("br"),t._v(" "),v("img",{attrs:{src:"https://user-images.githubusercontent.com/79966015/173261345-ebb6acd2-855f-4941-9082-9b458bf0fd71.PNG",alt:"가중치 그래프"}})]),t._v(" "),v("li",[t._v("방향성\n"),v("ul",[v("li",[t._v("무방향 그래프 : 간선에 방향이 없는 그래프로, (A,B)로 표시합니다."),v("br"),t._v(" "),v("img",{attrs:{src:"https://user-images.githubusercontent.com/79966015/173261416-3e6321dc-7623-40fd-9a51-0d4a5b04f585.PNG",alt:"무뱡향그래프"}})]),t._v(" "),v("li",[t._v("방향 그래프 : 간선에 방향이 있는 그래프로, A->B로 가는 간선을 <A,B>로 표시합니다."),v("br"),t._v(" "),v("img",{attrs:{src:"https://user-images.githubusercontent.com/79966015/173261374-a49a0d7b-e043-4316-80d3-35335392d56a.PNG",alt:"방향그래프"}})])])]),t._v(" "),v("li",[t._v("사이클\n"),v("ul",[v("li",[t._v("순환 그래프 : 단순 경로에서 시작정점과 도착정점이 동일한 그래프입니다."),v("br"),t._v(" "),v("img",{attrs:{src:"https://user-images.githubusercontent.com/79966015/173261489-31dc0e4d-9014-4890-b03e-7b09fbc8f10a.PNG",alt:"순환그래프"}})]),t._v(" "),v("li",[t._v("비순환 그래프 : 순환 그래프를 제외한 그래프로, 사이클이 없는 그래프입니다."),v("br"),t._v(" "),v("img",{attrs:{src:"https://user-images.githubusercontent.com/79966015/173261497-7813f18f-c1d5-47a7-9bd0-b04d2554eff5.PNG",alt:"비순환그래프"}})])])]),t._v(" "),v("li",[t._v("연결\n"),v("ul",[v("li",[t._v("연결 그래프 : 무방향 그래프에서 노드들이 모두 간선에 의해 연결되어 있는 그래프로, 트리(tree)가 대표적인 예입니다."),v("br"),t._v(" "),v("img",{attrs:{src:"https://user-images.githubusercontent.com/79966015/173261502-b8d72569-2f32-401d-8df8-b8719339b61c.PNG",alt:"연결그래프"}})]),t._v(" "),v("li",[t._v("비연결 그래프 : 무방향 그래프에서 간선에 의해 연결되어 있지 않은 노드가 있는 그래프입니다."),v("br"),t._v(" "),v("img",{attrs:{src:"https://user-images.githubusercontent.com/79966015/173261507-1b60a39b-71cd-4daf-a444-510baf8891d4.PNG",alt:"비연결그래프"}})]),t._v(" "),v("li",[t._v("완전 그래프 : 그래프의 모든 정점이 서로 연결되어 있는 그래프입니다."),v("br"),t._v(" "),v("img",{attrs:{src:"https://user-images.githubusercontent.com/79966015/173261515-137cdc53-938e-44c5-aa53-b99798d846b3.PNG",alt:"완전그래프"}})])])])]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("오일러 경로")]),t._v(" "),v("p",[t._v("그래프에 존재하는 모든 간선을 한번만 통과하면서 처음 정점으로 되돌아오는 경로를 말합니다.\n그래프의 모든 정점에 연결된 간선의 개수가 짝수일 때만 오일러 경로가 존재합니다.")])]),t._v(" "),v("h2",{attrs:{id:"그래프의-표현"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#그래프의-표현"}},[t._v("#")]),t._v(" 그래프의 표현")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("인접 행렬 (Adjacency Matrix)"),v("br"),t._v("\n인접행렬은 그래프의 노드를 2차원으로 만든 것입니다."),v("br"),t._v("\n노드들 간에 직접 연결이 되어 있으면 1을, 아니면 0을 넣어서 행렬을 완성시킵니다."),v("br"),t._v(" "),v("img",{attrs:{src:"https://user-images.githubusercontent.com/79966015/173263886-31edb44e-02c0-4e0c-8525-a16e29bb2566.PNG",alt:"인접행렬"}})]),t._v(" "),v("ul",[v("li",[t._v("장점\n"),v("ol",[v("li",[t._v("두 정점에 대한 연결 정보(M[i][j])를 조회할 때 O(1)의 시간복잡도가 걸립니다.")]),t._v(" "),v("li",[t._v("인접리스트에 비해 구현이 쉽습니다.")]),t._v(" "),v("li",[t._v("정점의 차수를 O(n)안에 알 수 있습니다.")])])]),t._v(" "),v("li",[t._v("단점\n"),v("ol",[v("li",[t._v("항상 n^2개의 메모리 공간이 필요해, 공간이 낭비될 경우가 많습니다.")]),t._v(" "),v("li",[t._v("인접한 노드를 찾기 위해서는 모든 노드를 전부 순회해야 합니다.")])])])])]),t._v(" "),v("li",[v("p",[t._v("인접 리스트 (Adjacency List)"),v("br"),t._v("\n인접리스트는 그래프의 노드를 리스트로 표현한 것입니다.\n그래프를 표현하는 가장 일반적인 방식입니다."),v("br"),t._v(" "),v("img",{attrs:{src:"https://user-images.githubusercontent.com/79966015/173263890-a0ed0ffa-dd41-4102-ac51-de0dff604662.PNG",alt:"인접리스트"}})])])]),t._v(" "),v("ul",[v("li",[t._v("장점\n"),v("ol",[v("li",[t._v("노드에 인접한 노드들을 쉽게 찾을 수 있습니다.")]),t._v(" "),v("li",[t._v("공간의 낭비가 적습니다.")]),t._v(" "),v("li",[t._v("그래프에 존재하는 모든 간선의 수를 O(n+e)안에 알 수 있습니다.")])])]),t._v(" "),v("li",[t._v("단점\n"),v("ol",[v("li",[t._v("특정 두 점이 연결되어있는 지 확인하려면 인접행렬에 비해 사간이 걸립니다. O(e)시간 소요.")]),t._v(" "),v("li",[t._v("구현이 비교적 어렵습니다.")])])])]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("선택 기준")]),t._v(" "),v("p",[t._v("그래프에 간선이 많이 존재하는 밀집그래프의 경우에는 인접행렬을,\n그래프에 적은 간선을 가지는 희소그래프의 경우에는 인접리스트를 사용하는게 좋습니다.")])]),t._v(" "),v("h2",{attrs:{id:"그래프의-탐색"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#그래프의-탐색"}},[t._v("#")]),t._v(" 그래프의 탐색")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("깊이 우선 탐색(DFS, Depth-First Search)")]),t._v(" "),v("ul",[v("li",[t._v("루트 노드(혹은 다른 임의의 노드)에서 시작해서 다음 분기(branch)로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방법입니다.")]),t._v(" "),v("li",[t._v("넓게(wide) 탐색하기 전에 깊게(deep) 탐색하는 것입니다.")]),t._v(" "),v("li",[t._v("모든 노드를 방문하고자 할 때 사용하는게 좋습니다.")])])]),t._v(" "),v("li",[v("p",[t._v("너비 우선 탐색(BFS, Breadth-First Search)")]),t._v(" "),v("ul",[v("li",[t._v("루트 노드(혹은 다른 임의의 노드)에서 시작해서 인접한 노드를 먼저 탐색하는 방법입니다.")]),t._v(" "),v("li",[t._v("깊게(deep)탐색하기 전에 넓게(wide)탐색하는 것입니다.")]),t._v(" "),v("li",[t._v("두 노드 사이의 최단 경로, 임의의 경로를 찾고 싶을 때 사용하는게 좋습니다.")])])])]),t._v(" "),v("h2",{attrs:{id:"그래프와-신장트리"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#그래프와-신장트리"}},[t._v("#")]),t._v(" 그래프와 신장트리")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("신장트리(Spanning Tree)")]),t._v(" "),v("ul",[v("li",[t._v("연결 그래프의 부분그래프로서 그 그래프의 모든 정점과 간선의 부분 집합으로 구성되는 트리입니다.")]),t._v(" "),v("li",[t._v("모든 노드는 적어도 하나의 간선에 연결되어 있어야 하지만, 사이클이 형성되면 안됩니다.")]),t._v(" "),v("li",[t._v("연결 그래프일 때 DFS, BFS를 통해서 구현이 가능합니다."),v("br"),t._v(" "),v("img",{attrs:{src:"https://user-images.githubusercontent.com/79966015/173264518-0472880e-590f-4e63-93b8-8c7cc2583309.PNG",alt:"신장트리"}})])])]),t._v(" "),v("li",[v("p",[t._v("최소 비용 신장 트리(Minimum Cost Spaning Tree)")]),t._v(" "),v("ul",[v("li",[t._v("신장트리 중 간선의 가중치 합이 최소인 신장트리입니다.")]),t._v(" "),v("li",[t._v("프림(Prim), 크루스칼(Kruskal) 등을 통해 최소비용신장트리를 찾아낼 수 있습니다."),v("br"),t._v(" "),v("img",{attrs:{src:"https://user-images.githubusercontent.com/79966015/173265256-df53c5f6-6c48-4071-b40d-97078f0fb71c.PNG",alt:"최소비용신장트리"}})])])])]),t._v(" "),v("h3",{attrs:{id:"참고자료"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#참고자료"}},[t._v("#")]),t._v(" 참고자료")]),t._v(" "),v("p",[t._v("출처: https://hongcoding.tistory.com/78"),v("br"),t._v("\n출처: https://gmlwjd9405.github.io/2018/08/13/data-structure-graph.html"),v("br"),t._v("\n출처: https://kingpodo.tistory.com/49")])])}),[],!1,null,null,null);v.default=a.exports}}]);