(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{273:function(v,_,t){"use strict";t.r(_);var r=t(13),i=Object(r.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"객체지향-vs-절차형-프로그래밍"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#객체지향-vs-절차형-프로그래밍"}},[v._v("#")]),v._v(" 객체지향 VS 절차형 프로그래밍")]),v._v(" "),_("h2",{attrs:{id:"객체지향-프로그래밍이란-무엇인가요"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#객체지향-프로그래밍이란-무엇인가요"}},[v._v("#")]),v._v(" 객체지향 프로그래밍이란 무엇인가요?")]),v._v(" "),_("p",[v._v("객체지향 프로그래밍(Object-Oriented Programming)은 객체들의 집합으로 프로그램의 상호 작용을 표현하며\n데이터를 객체로 취급하여 객체 내부에 선언된 메서드를 활용하는 방식을 말합니다.")]),v._v(" "),_("ul",[_("li",[v._v("장점\n"),_("ul",[_("li",[v._v("코드 재사용이 용이합니다.")]),v._v(" "),_("li",[v._v("유지보수가 편리합니다.")]),v._v(" "),_("li",[v._v("대형 프로젝트에 적합합니다.")])])]),v._v(" "),_("li",[v._v("단점\n"),_("ul",[_("li",[v._v("설계에 많은 시간이 소요됩니다.")]),v._v(" "),_("li",[v._v("처리속도가 다른 프로그래밍 패러다임에 비해 상대적으로 느립니다.")])])])]),v._v(" "),_("h2",{attrs:{id:"객체지향의-특징"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#객체지향의-특징"}},[v._v("#")]),v._v(" 객체지향의 특징")]),v._v(" "),_("ul",[_("li",[v._v("추상화"),_("br"),v._v("\n추상화(abstraction)란 복잡한 시스템으로부터 핵심적인 개념 또는 기능을 간추려내는것을 의미합니다.")]),v._v(" "),_("li",[v._v("캡슐화"),_("br"),v._v("\n캡슐화(encapsulation)는 객체의 속성과 메서드를 하나로 묶고 일부를 외부에 감추어 은닉하는 것을 말합니다.")]),v._v(" "),_("li",[v._v("상속성"),_("br"),v._v("\n상속성(inheritance)은 상위 클래스의 특성을 하위 클래스가 이어받아서 재사용하거나 추가, 확장하는 것을 말합니다."),_("br"),v._v("\n코드의 재사용측면, 계층적인 관계 생성, 유지 보수성 측면에서 중요한 부분입니다.")]),v._v(" "),_("li",[v._v("다형성"),_("br"),v._v("\n다형성(polymorphism)은 하나의 메서드나 클래스가 다양한 방법으로 동작하는 것을 말합니다."),_("br"),v._v("\n대표적으로 오버로딩, 오버라이딩이 있습니다.")])]),v._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),_("p",[v._v("오버로딩(overloading) : 같은 이름을 가진 메서드를 여러 개 두는 것을 말합니다.\n메서드의 타입, 매개변수의 유형, 개수 등으로 여러개를 둘 수 있으며 컴파일 중에 발생하는 정적다형성입니다."),_("br"),v._v("\n오버라이딩(overriding) : 주로 메서드 오버라이딩을 말하며 상위 클래스로부터 상속받은 메서드를 하위 클래스가 재정의하는 것을 의미합니다.\n런타임 중에 발생하는 동적다형성입니다.")])]),v._v(" "),_("h2",{attrs:{id:"클래스와-인스턴스의-차이"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#클래스와-인스턴스의-차이"}},[v._v("#")]),v._v(" 클래스와 인스턴스의 차이")]),v._v(" "),_("p",[v._v("클래스 : 어떤 문제를 해결하기 위한 데이터를 만들기 위해 추상화를 거쳐 집단에 속하는 속성(attribute)과 행위(behavior)를 변수와 메서드로 정의한 것입니다.\n객체를 만들기 위한 틀이라고 볼 수 있습니다."),_("br"),v._v("\n인스턴스 : 클래스에서 정의한 것을 토대로 실제 메모리에 할당된 것으로 실제 프로그램에서 사용되는 데이터(객체)입니다.")]),v._v(" "),_("h2",{attrs:{id:"객체지향의-설계원칙"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#객체지향의-설계원칙"}},[v._v("#")]),v._v(" 객체지향의 설계원칙")]),v._v(" "),_("p",[v._v("SOLID 원칙을 지켜주어야합니다.")]),v._v(" "),_("ul",[_("li",[v._v("S : 단일 책임 원칙"),_("br"),v._v("\n단일 책임 원칙(SRP, Single Responsibility Principle)은 모든 클래스는 각각 하나의 책임만 가져야 하는 원칙입니다.\n예를 들어, A라는 로직이 존재한다면 어떠한 클래스는 A에 관한 클래스여야 하고 이를 수정한다고 했을 때도 A와 관련된 수정이어야 합니다.")]),v._v(" "),_("li",[v._v("O : 개방-폐쇄 원칙"),_("br"),v._v("\n개방-폐쇄 원칙(OCP, Open Closed Principle)은 유지 보수 사항이 생긴다면 코드를 쉽게 확장할 수 있도록 하고 수정할 때는 닫혀 있어야 하는 원칙입니다.\n즉, 기존의 코드는 잘 변경하지 않으면서도 확장은 쉽게 할 수 있어야합니다.")]),v._v(" "),_("li",[v._v("L : 리스코프 치환 원칙"),_("br"),v._v("\n리스코프 치환 원칙(LSP, Liskov Substitution Principle)은 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 하는 것을 의미합니다.\n클래스는 상속이 되기 마련이고 부모, 자식이라는 계층 관계가 만들어집니다.\n이때 부모 객체에 자식 객체를 넣어도 시스템이 문제없이 돌아가게 만드는 것을 말합니다.")]),v._v(" "),_("li",[v._v("I : 인터페이스 분리 원칙"),_("br"),v._v("\n인터페이스 분리 원칙(ISP, Interface Segregation Principle)은 하나의 일반적인 인터페이스보다 구체적인 여러 개의 인터페이스를 만들어야 하는 원칙을 말합니다.")]),v._v(" "),_("li",[v._v("D : 의존 역전 원칙"),_("br"),v._v("\n의존 역전 원칙(DIP, Dependency Inversion Principle)은 자신보다 변하기 쉬운것에 의존하던 것을 추상화된 인터페이스나 상위 클래스를 두어 변하기 쉬운것의 변화에 영향받지 않게하는 원칙을 발합니다.\n예를 들어 타이어를 갈아끼울수 있는 틀을 만들어 놓은 후 다양한 타이어를 교체할 수 있어야 합니다. 즉, 상위 계층은 하위 계층의 변화에 대한 구현으로부터 독립해야합니다.")])]),v._v(" "),_("h2",{attrs:{id:"대표적인-객체지향-프로그래밍"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#대표적인-객체지향-프로그래밍"}},[v._v("#")]),v._v(" 대표적인 객체지향 프로그래밍")]),v._v(" "),_("p",[v._v("JAVA, C++, C#, JAVASCRIPT, 루비 등이 있습니다.")]),v._v(" "),_("h2",{attrs:{id:"절차형-프로그래밍이란-무엇인가요"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#절차형-프로그래밍이란-무엇인가요"}},[v._v("#")]),v._v(" 절차형 프로그래밍이란 무엇인가요?")]),v._v(" "),_("p",[v._v("절차형 프로그래밍은 로직이 수행되어야 할 연속적인 계산 과정으로 이루어져 있습니다.")]),v._v(" "),_("ul",[_("li",[v._v("장점\n"),_("ul",[_("li",[v._v("일이 진행되는 방식으로 코드가 구현되어, 코드의 가독성이 좋습니다.")]),v._v(" "),_("li",[v._v("실행속도가 빠릅니다.")])])]),v._v(" "),_("li",[v._v("단점\n"),_("ul",[_("li",[v._v("모듈화하기가 어렵습니다.")]),v._v(" "),_("li",[v._v("유지 보수성이 떨어집니다.")])])])]),v._v(" "),_("h2",{attrs:{id:"대표적인-절차형-프로그래밍"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#대표적인-절차형-프로그래밍"}},[v._v("#")]),v._v(" 대표적인 절차형 프로그래밍")]),v._v(" "),_("p",[v._v("C, ALGOL, COBOL, FORTRAN 등이 있습니다.")]),v._v(" "),_("h3",{attrs:{id:"참고자료"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#참고자료"}},[v._v("#")]),v._v(" 참고자료")]),v._v(" "),_("ul",[_("li",[v._v("주홍철."),_("em",[v._v("면접을 위한 CS 전공지식 노트")]),v._v(".서울:길벗,2022.")]),v._v(" "),_("li",[v._v("https://jeong-pro.tistory.com/95")])])])}),[],!1,null,null,null);_.default=i.exports}}]);