# 큐 (Queue)

:::tip 정의
큐는 먼저 집어넣은 데이터가 먼저 나오는 성질(FIFO, First In First Out)을 지닌 자료구조입니다.
:::

![image](https://user-images.githubusercontent.com/50647845/172971180-371028a7-1cd7-43d4-9c51-4dec80aca9c5.png)

- 먼저 집어넣은 데이터가 먼저 나오는 스택과는 반대의 개념입니다.
- 한 쪽 끝은 프런트(front)로 정하여 삭제 연산만 수행함
- 다른 한 쪽 끝은 리어(rear)로 정하여 삽입 연산만 수행함
- CPU 작업을 기다리는 프로세스, 스레드 행렬 또는 네트워크 접속을 기다리는 행렬, 너비 우선 탐색(BFS), 캐시 등에 사용됩니다.

## 데이터 삽입&삭제 속도

- `O(1)`
- 입구 데이터를 바로 삽입하고, 출구에서 바로 삭제(꺼내기)하면 됩니다.

## 데이터 탐색 속도

- `O(n)`
- 찾는 데이터가 존재하는지 투입된 순서대로 순차 검색이 필요합니다.
- 따라서 운이 안좋으면 저장된 모든 값을 확인해야 할 수도 있습니다.

:::warning 큐의 발전
일반 큐의 단점 : 큐에 빈 메모리가 남아 있어도, 꽉 차있는것으로 판단할 수도 있습니다. (`rear`가 끝에 도달했을 때)  
원형 큐 : 논리적으로 배열의 처음과 끝이 연결되어 있는 것으로 간주합니다.  
원형 큐의 단점 : 메모리 공간은 잘 활용하지만, 배열로 구현되어 있기 때문에 큐의 크기가 제한됩니다.  
연결리스트 큐 : 크기 제한이 없고 삽입, 삭제가 편리합니다.
:::

## 자바에서의 Queue

![image](https://user-images.githubusercontent.com/50647845/172972086-cf66b406-e371-414d-b398-452b6c9516d6.png)

- `Collection` 인터페이스를 상속 받는 인터페이스 입니다.

```java
import java.util.Queue;
import java.util.LinkedList;

public class Sample {
    public static void main(String[] args) {
        // 큐 만들기
        Queue<Integer> queue = new LinkedList<>(); // linkedlist 이용
        
        // 값을 삽입하는데 문제가 없으면 데이터를 그대로 삽입하는 메소드
        queue.offer(1); // true
        
        // 값을 추가하기
        queue.add(2);
        queue.add(3);
        
        // 값을 찍먹하는데 문제가 없으면 가장 앞의 값 찍먹하기
        queue.peek(); // 1
        
        // 가장 앞의 값 찍먹하기
        queue.element(); // 1
        
        // 값을 삭제하는데 문제가 없으면 값을 삭제하기 (꺼내기)
        queue.poll(); // 1
        
        // 값을 삭제하기 (꺼내기)
        queue.remove(); // 2
    }
}
```

- 위의 항목은 오로지 `Queue` 인터페이스에서만 추가된 메소드입니다.
- `offer()`와 `add()`는 동일한 역할을 수행하는 것처럼 보이지만, 차이점은 `add()`는 공간이 부족해서 삽입이 불가할 때 `IllegalStateException`이 발샙합니다.
- `peek()`와 `element()`는 동일한 역할을 수행하는 것처럼 보이지만, 차이점은 `element()`는 비어있는 상태 일 때 `NoSuchElementException`이 발샙합니다.
- `poll()`와 `remove()`는 동일한 역할을 수행하는 것처럼 보이지만, 차이점은 `remove()`는 비어있는 상태 일 때 `NoSuchElementException`이 발샙합니다.

![image](https://user-images.githubusercontent.com/50647845/172973351-82140718-eb0f-471c-b929-ed7d7b6d114f.png)

- 다른 메소드는 `Collections` 인터페이스 의 메소드를 이용합니다.
- 결국 둘다 인터페이스이기에 구현체인 `LinkedList`에서 호출되는 것이지만....

## 2개의 스택으로 큐를 구현하기

![image](https://user-images.githubusercontent.com/50647845/172973857-18ca0859-8a07-4630-8f84-35e4d01cd6c7.png)

1. inbox에 데이터를 삽입한다(push) -> A,B
2. inbox에 있는 데이터를 추출(pop)하여 outbox에 삽입(push) 한다. -> B,A
3. outbox에 있는 데이터를 추출(pop)한다. -> A,B 순으로 출력된다.

```java
import java.util.Stack;

public class Queue {
	private Stack inBox = new Stack();
	private Stack outBox = new Stack();
	
	public void enQueue(Object item) {
		inBox.add(item);
	}
	
	public Object deQueue() {
		if (outBox.isEmpty()) {
			while(!inBox.isEmpty()) {
				outBox.push(inBox.pop());
			}
		}
		return outBox.pop();
	}
	
	public static void main(String[] args) {
		Queue queue = new Queue();
		queue.enQueue("A");
		queue.enQueue("B");
		queue.enQueue("C");
		
		System.out.println(queue.deQueue());
		System.out.println(queue.deQueue());
		System.out.println(queue.deQueue());
	}
}
```

## 덱(Deque)이란?

:::tip 정의
`Deque`(덱 혹은 데크)은 `Double-Ended Queue`의 줄임말로 큐의 양쪽으로 엘리먼트의 삽입과 삭제를 수행할 수 있는 자료구조(양방향 대기열)입니다.
:::

![image](https://user-images.githubusercontent.com/50647845/172974741-eda5f98d-8063-43c8-80fe-42696a8c3d14.png)

- 덱은 어떤 쪽으로 입력하고 어떤 쪽으로 출력하느냐에 따라서 스택으로 사용할 수도 있고, 큐로도 사용할 수 있습니다. 
- 특히 한쪽으로만 입력 가능하도록 설정한 덱을 스크롤(scroll)이라고 하며, 한쪽으로만 출력 가능하도록 설정한 덱을 셸프(shelf)라고 합니다.

## 자바에서의 Deque

![image](https://user-images.githubusercontent.com/50647845/172975629-9a336154-a5fc-485c-b3d2-8cc244392918.png)

- `Deque`인터페이스이며, 이를 구현한 ArrayDeque, LinkedBlockingDeque, ConcurrentLinkedDeque, LinkedList 등의 클래스가 있습니다.

![image](https://user-images.githubusercontent.com/50647845/172975265-e0cedc37-7526-4351-a2f0-62b5e87ece69.png)


```java
import java.util.Deque;
import java.util.ArrayDeque;

public class Sample {
    public static void main(String[] args) {
        // 덱 만들기
        Deque<Integer> deque = new ArrayDeque<>();
        
        // 값을 앞에 삽입
        deque.offerFirst(1);
        deque.addFirst(2); // 문제가 있으면 NullPointerException 
        
        // 값을 뒤에 삽입
        deque.offerLast(5);
        deque.addLast(3); // 문제가 있으면 NullPointerException 
        deque.add(4); // 문제가 있으면 NullPointerException 
        
        // 가장 앞의 값 찍먹하기
        deque.peek();
        deque.peekFirst();
        deque.getFirst(); // 문제가 있으면 NullPointerException
        deque.element(); // 문제가 있으면 NoSuchElementException
        
        // 가장 뒤의 값 찍먹하기
        queue.getLast(); // 문제가 있으면 NullPointerException
        queue.peekLast();
        
        // 값을 순서대로 삭제하기 (꺼내기)
        deque.pollFirst();
        deque.poll();
        deque.removeFirst(); // 문제가 있으면 NoSuchElementException
        deque.remove(); // 문제가 있으면 NoSuchElementException
        
        // 값을 마지막부터 삭제하기
        deque.pollLast();
        deque.removeLast(); // 문제가 있으면 NoSuchElementException
    }
}
```

![image](https://user-images.githubusercontent.com/50647845/172978335-88400d3f-dc70-4791-9205-9b38ece8f2a5.png)

![image](https://user-images.githubusercontent.com/50647845/172978379-9e68ba3a-2e29-4d35-8b19-91a4c005b9c8.png)

![image](https://user-images.githubusercontent.com/50647845/172978419-4f0c3eae-b38f-47f3-9560-3beb64a4b115.png)

### 참고자료

- 주홍철.*면접을 위한 CS 전공지식 노트*.서울:길벗,2022.
- [Oracle Doc - Queue](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Queue.html)
- [Oracle Doc - Deque](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Deque.html)
- [HyeminNoh](https://github.com/HyeminNoh/Tech-Stack)
- [gyoogle](https://github.com/gyoogle/tech-interview-for-developer)
- [DevAndy](https://youngjinmo.github.io/2021/05/java-queue/)
- [Creator Developer:티스토리](https://creatordev.tistory.com/83)
- [월급쟁이의 경제적 자유](https://soft.plusblog.co.kr/24)
- [차근차근 개발일기+일상:티스토리](https://crazykim2.tistory.com/581)
